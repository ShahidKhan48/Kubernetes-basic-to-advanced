# Pod Examples - Real-time Production Ready Configurations

---
# Basic Pod Example
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
    environment: production
    version: "1.0"
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
      name: http
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"

---
# Multi-container Pod with Sidecar Pattern
apiVersion: v1
kind: Pod
metadata:
  name: web-app-with-sidecar
  labels:
    app: web-app
    pattern: sidecar
spec:
  containers:
  # Main application container
  - name: web-app
    image: nginx:1.21
    ports:
    - containerPort: 80
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"
  
  # Sidecar container for log processing
  - name: log-processor
    image: fluent/fluent-bit:1.8
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    - name: fluent-bit-config
      mountPath: /fluent-bit/etc
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"
  
  volumes:
  - name: shared-logs
    emptyDir: {}
  - name: fluent-bit-config
    configMap:
      name: fluent-bit-config

---
# Pod with Health Checks and Environment Variables
apiVersion: v1
kind: Pod
metadata:
  name: api-server-pod
  labels:
    app: api-server
    tier: backend
spec:
  containers:
  - name: api-server
    image: node:16-alpine
    command: ["node", "server.js"]
    ports:
    - containerPort: 3000
      name: api-port
    env:
    - name: NODE_ENV
      value: "production"
    - name: DATABASE_URL
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: url
    - name: API_KEY
      valueFrom:
        configMapKeyRef:
          name: api-config
          key: api-key
    
    # Health checks
    livenessProbe:
      httpGet:
        path: /health
        port: 3000
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3
    
    readinessProbe:
      httpGet:
        path: /ready
        port: 3000
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3
    
    resources:
      requests:
        memory: "256Mi"
        cpu: "200m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    
    # Security context
    securityContext:
      runAsNonRoot: true
      runAsUser: 1000
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
    
    volumeMounts:
    - name: tmp-volume
      mountPath: /tmp
    - name: app-config
      mountPath: /app/config
      readOnly: true
  
  volumes:
  - name: tmp-volume
    emptyDir: {}
  - name: app-config
    configMap:
      name: app-config
  
  # Pod-level security context
  securityContext:
    fsGroup: 1000
  
  # Node selection
  nodeSelector:
    kubernetes.io/os: linux
  
  # Restart policy
  restartPolicy: Always

---
# Pod with Init Container
apiVersion: v1
kind: Pod
metadata:
  name: database-pod
  labels:
    app: database
    component: storage
spec:
  # Init container to set up database
  initContainers:
  - name: db-migration
    image: migrate/migrate:v4.15.2
    command: ['migrate', '-path', '/migrations', '-database', 'postgres://user:pass@localhost/db', 'up']
    volumeMounts:
    - name: migration-scripts
      mountPath: /migrations
    env:
    - name: DATABASE_URL
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: url
  
  containers:
  - name: postgres
    image: postgres:13
    ports:
    - containerPort: 5432
      name: postgres
    env:
    - name: POSTGRES_DB
      value: "myapp"
    - name: POSTGRES_USER
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: POSTGRES_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    
    volumeMounts:
    - name: postgres-storage
      mountPath: /var/lib/postgresql/data
    - name: postgres-config
      mountPath: /etc/postgresql/postgresql.conf
      subPath: postgresql.conf
    
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
    
    livenessProbe:
      exec:
        command:
        - pg_isready
        - -U
        - $(POSTGRES_USER)
        - -d
        - $(POSTGRES_DB)
      initialDelaySeconds: 30
      periodSeconds: 10
    
    readinessProbe:
      exec:
        command:
        - pg_isready
        - -U
        - $(POSTGRES_USER)
        - -d
        - $(POSTGRES_DB)
      initialDelaySeconds: 5
      periodSeconds: 5
  
  volumes:
  - name: postgres-storage
    persistentVolumeClaim:
      claimName: postgres-pvc
  - name: postgres-config
    configMap:
      name: postgres-config
  - name: migration-scripts
    configMap:
      name: db-migrations

---
# Pod with Affinity and Tolerations
apiVersion: v1
kind: Pod
metadata:
  name: high-performance-app
  labels:
    app: high-performance
    performance: critical
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        memory: "2Gi"
        cpu: "1000m"
      limits:
        memory: "4Gi"
        cpu: "2000m"
  
  # Node affinity - prefer nodes with SSD storage
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/os
            operator: In
            values:
            - linux
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
          - key: storage-type
            operator: In
            values:
            - ssd
  
  # Tolerations for dedicated nodes
  tolerations:
  - key: "dedicated"
    operator: "Equal"
    value: "high-performance"
    effect: "NoSchedule"
  
  # Priority class for important workloads
  priorityClassName: high-priority